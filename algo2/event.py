#!/usr/bin/python
# -*- coding: utf-8  -*-
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

from enum import Enum

EventType = Enum("EventType", "TICK BAR SIGNAL ORDER FILL")


##########################################
class Event(object):
    """
    Event is the base class, provinding an interface
    for all inherited that will be created/stored
    
    """
#    @property
#    def typename(self):
#        return self.type.name
    pass


##########################################
class MarketEvent(Event):
    """
    Handles the event of receiving a new market update
    and triggers Strategy to generate signals.
    
    Datafeed ->  MarketEvent -> Strategy
    """

    def __init__(self):
        """
        Initialises the MarketEvent.
        """
        self.type = 'MARKET'


# MarketEvent
# can be expressed in one of the following ways:
class TickEvent(Event):
    """
    Handles the event of receiving a new market update tick,
    which is defined as a ticker symbol and associated best
    bid and ask from the top of the order book.
    """

    def __init__(self, ticker, time, bid, ask):
        """
        :param ticker - The ticker symbol, e.g. 'GOOG'.
        :param time - The timestamp of the tick
        :param bid - The best bid price at the time of the tick.
        :param ask - The best ask price at the time of the tick.
        """
        self.type = EventType.TICK  # i.e. = "TICK"
        self.ticker = ticker
        self.time = time
        self.bid = bid
        self.ask = ask

    def __str__(self):
        return "Type: %s, Ticker: %s, Time: %s, Bid: %s, Ask: %s" % (
            str(self.type), str(self.ticker),
            str(self.time), str(self.bid), str(self.ask)
        )

    def __repr__(self):
        return str(self)


class BarEvent(Event):
    """
    Handles the event of receiving a new market
    open-high-low-close-volume bar, as would be generated
    via common data providers such as Yahoo Finance.
    """

    def __init__(
            self, ticker, time, period,
            open_price, high_price, low_price,
            close_price, volume, adj_close_price=None
    ):
        """
        :param ticker - The ticker symbol, e.g. 'GOOG'.
        :param time - The timestamp of the bar
        :param period - The time period covered by the bar in seconds
        :param open_price - The unadjusted opening price of the bar
        :param high_price - The unadjusted high price of the bar
        :param low_price - The unadjusted low price of the bar
        :param close_price - The unadjusted close price of the bar
        :param volume - The volume of trading within the bar
        :param adj_close_price - The vendor adjusted closing price         

        Note: It is not advised to use 'open', 'close' instead
        of 'open_price', 'close_price' as 'open' is a reserved
        word in Python.
        """
        self.type = EventType.BAR  # i.e. = "BAR"
        self.ticker = ticker
        self.time = time
        self.period = period
        self.open_price = open_price
        self.high_price = high_price
        self.low_price = low_price
        self.close_price = close_price
        self.volume = volume
        self.adj_close_price = adj_close_price


##########################################
class SignalEvent(Event):
    """
    Handles the event of sending a Signal from a Strategy object.
    This is received by a Portfolio object and acted upon.
    Strategy -> SignalEvent -> Portfolio (splittable in sizer and risk mgt)
    """

    def __init__(self, ticker, action, suggested_quantity=None):
        """
        Initialises the SignalEvent.

        :param ticker - ticker symbol
        deleted: datetime - timestamp at which the signal was generated.
        :param action - either 'BOT' (for long) or 'SLD' (for short).
        :param suggested_quantity - OPTIONAL suggested absolute quantity of units
            modified by PositionSizer and RiskManager.
        """
        # self.strategy_id = strategy_id # strategy_id - unique ID of the generated strategy signal.
        # self.datetime = datetime

        self.type = EventType.SIGNAL  # ='SIGNAL'
        self.ticker = ticker
        self.action = action
        self.suggested_quantity = suggested_quantity


##########################################
class SuggestedOrderEvent(Event):
    """
    A SuggestedOrder object is generated by the PortfolioHandler
    to be sent to the PositionSizer object and subsequently the
    RiskManager object. Creating a separate object type for
    suggested orders and final orders (OrderEvent objects) ensures
    that a suggested order is never transacted unless it has been
    scrutinised by the position sizing and risk management layers.
    """

    def __init__(self, ticker, action, quantity=0):
        """
        Initialises the SuggestedOrder. The quantity defaults
        to zero as the PortfolioHandler creates these objects
        prior to any position sizing.

        The PositionSizer object will "fill in" the correct
        value prior to sending the SuggestedOrder to the
        RiskManager.

        :param ticker - the ticker symbol, e.g. 'GOOG'.
        :param action - 'BOT' (for long) or 'SLD' (for short) [or 'EXIT' (for liquidation)].
        :param quantity - The quantity of contracts to transact.
        """
        self.ticker = ticker
        self.action = action
        self.quantity = quantity  # optional


##########################################
class OrderEvent(Event):
    """
    Handles the event of sending an Order to an execution system.
    The order contains a symbol (e.g. GOOG), a type (market or limit),
    quantity and a direction.
    Portfolio -> OrderEvent -> Execution
    """

    def __init__(self, ticker, action, quantity, type_of_order=None):
        """
        Initialises 
        1. order type, either Market order ('MKT') or Limit order ('LMT'), 
        2. quantity (integral) and 
        3. its direction ('BUY' or 'SELL').

        TODO: Must handle error checking here to obtain 
        rational orders (i.e. no negative quantities etc).

        Parameters:
        :param ticker - The instrument to trade.
        :param 'BUY' or 'SELL' for long or short.
        :param quantity - no. of instruments.
        :param type_of_order - OPTIONAL 'MKT' or 'LMT' for Market or Limit.
        """

        self.type = EventType.ORDER
        self.ticker = ticker
        self.action = action
        self.quantity = quantity
        self.type_of_order = type_of_order  # optional

    def print_order(self):
        """
        Outputs the values within the OrderEvent.
        """
        print(
            "Order: Ticker=%s, Action=%s, Quantity=%s, TypeOfOrder=%s" % (
                self.ticker, self.action, self.quantity, self.type_of_order
            )
        )


##########################################
class FillEvent(Event):
    """
    Encapsulates the notion of a Filled Order, as returned
    from a brokerage. Stores the quantity of an instrument
    actually filled and at what price. In addition, stores
    the commission of the trade from the brokerage.
    
    TODO: Currently does not support filling positions at
    different prices. This will be simulated by averaging
    the cost.
    """

    def __init__(
            self, timestamp, ticker,
            action, quantity,
            exchange, price,
            commission
    ):
        """
        Initialises the FillEvent object.

        :param timestamp - The timestamp when the order was filled.
        :param ticker - The ticker symbol, e.g. 'GOOG'.
        :param action - 'BOT' (for long) or 'SLD' (for short).
        :param quantity - The filled quantity.
        :param exchange - The exchange where the order was filled.
        :param price - The price at which the trade was filled
        :param commission - The brokerage commission for carrying out the trade.
        """

        self.type = EventType.FILL  # = 'FILL'
        self.timestamp = timestamp
        self.ticker = ticker
        self.action = action
        self.quantity = quantity
        self.exchange = exchange
        self.price = price
        self.commission = commission

    #        # REMOVED FROM HERE
    #        # Calculate commission
    #        if commission is None:
    #            self.commission = self.calculate_ib_commission()
    #        else:
    #            self.commission = commission

    #    def calculate_ib_commission(self):
    #    Calculates the fees of trading based on an Interactive
    #    Brokers fee structure for API, in USD.
    #    This does not include exchange or ECN fees.

# full_cost = 1.3
#        if self.quantity <= 500:
#            full_cost = max(1.3, 0.013 * self.quantity)
#        else: # Greater than 500
#            full_cost = max(1.3, 0.008 * self.quantity)
#        return full_cost
