#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import print_function

from abc import ABCMeta, abstractmethod

import datetime

try:
    import Queue as queue
except ImportError:
    import queue

from event import FillEvent, OrderEvent


class Broker(object):
    """
    The Broker abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market. 

    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Parameters:
        event - Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")


class SimulatedBroker(Broker):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """
    
    def __init__(self, events):
        """
        Initialises the handler, setting the event queues
        up internally.

        :param events - The Queue of Event objects.
        """
        self.events = events

    def execute_order(self, event):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.

        Parameters:
        event - Contains an Event object with order information.
        """
        if event.type == 'ORDER':
            fill_event = FillEvent(
                datetime.datetime.utcnow(), event.symbol,
                'Simulated Mkt', event.quantity, event.direction, None
            )
            self.events.put(fill_event)

"""
The simplest possible implementation is to assume all orders are filled at the current market price for
all quantities. This is clearly extremely unrealistic and a big part of improving backtest realism
will come from designing more sophisticated models of slippage and market impact.
Note that the FillEvent is given a value of None for the fill_cost (see the penultimate
line in execute_order) as we have already taken care of the cost of fill in the Portfolio object
described above. In a more realistic implementation we would make use of the "current" market
data value to obtain a realistic fill cost.
I have simply utilised 'Simulated Mkt' as the exchange although for backtesting purposes.
"""